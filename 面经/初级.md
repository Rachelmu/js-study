H5和CS部分
请描述一下 cookies, sessionStorage, localStorage 的区别?
分析: 考察求职者对于本地存储的方式是否熟悉, 因为初学者会把 cookies和 sessionStorage 与 localStorage 搞混
解答: 
cookies: 它是网站用来标记用户身份的一段数据, 通常情况下是一段加密的字符串, 并且默认情况下只会在同源( 同域名, 同端口, 同协议 )的 HTTP 请求中携带
sessionStorage: 它是浏览器本地储存的一种方式, 以键值对的形式进行储存, 并且储存的数据会在浏览器关闭之后进行自动删除
localStorage: 它也是浏览器本地储存的一种方式, 和sessionStorage一样, 也是以键值对的形式存在, 不过它储存的是一个持久化的数据, 一般不主动删除, 数据会一直存在

比如自己组织语言回答: 
首先我会说: cookies一般情况下是用来标记用户身份的一段数据, 一般是一段加密的字符串, 并且在默认的情况下, 我们的cookies只会在同源的 HTTP 请求中携带, sessionStorage呢其实是浏览器本地存储的一种方式, 并且是以键值对的形式存储到我们的浏览器本地, 但是我们通过sessionStorage存储的数据, 会在浏览器关闭之后自动删除, localStorage正好弥补了sessionStorage的不足, localStorage它也是浏览器本地存储的一种方式, 同样它也以键值对的形式存在, 不过呢, 我们通过localStorage保存的数据是一个持久化的数据, 一般情况下来说, 如果我们不主动去删除的情况下, 我们保存的数据会一直存在于我们的一个本地

请说出display: none;和visibility: hidden;的区别
分析: 这是一个比较容易出现错误的css问题, 没有大量实际开发经验的开发者, 很难了解他们之间的区别
解答: 
● 共同点: 他们都可以让元素不可见
● 不同点: 
  ○ display: none; 会让元素完全从渲染树中消失, 不渲染的时候不占据任何空间。而visibility: hidden; 不会让元素从渲染树消失, 不渲染时元素继续占用空间, 只是内容不可见
  ○ display: none; 是非继承属性, 子孙节点消失是因为元素从渲染树消失造成, 通过修改子孙节点属性无法显示; 而visibility: hidden; 是继承属性, 子孙节点消失由于继承了hidden, 通过设置visibility: visible; 可以让子孙节点显示
能回答出不同点第一条就已经将核心点回答出来了, 第二条是加分项

我们用自己的语言回答一下
他们都会将元素隐藏(不可见), 但是不同的地方就在于, display: none; 设置之后, 元素会从我们的渲染树中消失, 不再占据任何的空间, 然而我们设置visibility为hidden时, 并不会将元素从渲染树上消失, 只是将内容进行隐藏, 依然占用空间


为什么要初始化css样式
分析:  这个问题主要是看你有没有实际开发经验, 因为对于没有实际开发经验的同学, 是不知道在正式项目开发时要初始化css样式的, 也就是清楚掉一些元素默认所携带的样式, 比如: 默认的padding和margin
解答: 
● 因为浏览器的兼容问题, 不同浏览器对有些元素的默认样式是不同的, 并且默认的样式会因修改那个到项目最终的布局, 如果没对css初始化, 那么有可能会出现浏览器之间的页面显示差异


什么是postcss, 以及postcss有什么作用?
分析: 有很多已经工作了两年、三年的开发者依然无法理解清楚 postcss 是什么, 以及它的作用
解答: 
● 首先明确 postcss 是一个平台
● 基于这个平台, 可以使用一些插件, 来优化 css 的代码, 比如说: autoprefixer 插件, 他就需要基于 postcss 使用, 作用是可以帮助我们为css增加上不同的浏览器前缀。

JS方面
解释一下什么是闭包? 以及闭包解决了什么问题?
分析: 闭包的问题一直是前端方面非常被关注的问题, 这个问题作为面试题经久不衰
解答: 
● 什么是闭包?
  ○ 闭包就是能够读取其他函数内部变量的一个函数, 通常情况下, 我们会在一个函数中, 去创建另外一个函数, 然后通过新创建的这个函数来访问上层函数的局部变量, 被访问到的局部变量会始终保存在内存之中。

自己话术理解: 闭包其实就是一个作用域有权访问另一个作用域的局部变量, 通常情况下, 我们会在一个函数中创建另一个函数, 然后在新创建的函数中来访问上层函数的局部变量, 这个时候, 被访问到的局部变量会始终保存在内存之中。

原型和原型链分别是什么?有什么特点
分析: 原型和原型链的问题和闭包一样, 也是面试被问到频率很高的一个问题, 一般情况下, 会因为这个问题来压工资
解答: 
● 每一个函数都有prototype属性, 这个属性会指向一个对象, 就是通过调用该构造函数而创建的实例的原型, 可以通过实例对象的__proto__来访问到这个原型对象
● 实例在创建时, 就会默认关联原型, 并且会从原型继承属性
● 而每一个原型对象又都会存在一个constructor属性, 这个属性会指向关联的这个构造函数
● 当访问一个实例对象的属性时, 如果说这个实例对象中没有这个属性, 那么JS引擎就会去该实例对象的原型对象中去找
● 如果属性在原型对象中也找不到, 那么就会去原型的原型中去找, 一直找到最上层的原型, 也就是Object为止


谈谈对This对象的理解
在js中一直存在着一个本不应该存在的问题(因为他是一个bug), 那就是关于this指向的问题, 关于this的指向在其他语言中(比如: java)是非常明确地, 但是因为js的历史原因, 导致this的指向一直都是重难点

解答: 
● this总是指向函数的直接调用者 (而非间接调用者)
● 如果有new关键字, this指向new出来的那个对象
● 在事件中, this指向触发这个事件的对象, 特殊的是, IE中的attachEvent中的this总是指向全局对象Window

谈谈你对webpack的看法
分析: 对于中级工程师来说, webpack的内容一般不会问的很深, 因为除非是高软或者是架构师, 否则一般不会去配置webpack, 但是这并不是你光明正大说不会的理由
解答: 
● webpack是一个js的模块打包工具, 可以使用webpack管理项目中的js模块依赖
● webpack提供了一些默认的配置, 比如说: devServer, 我们可以利用devServer来快速启动一个开发时的web服务器。
● 并且因为webpack默认只能打包js文件, 所以webpack额外提供了loader的概念, 我们可以使用loader来预处理一些文件, 并且可以打包除了js之外的任何静态资源
● 另外webpack还提供了插件的概念, 我们可以使用很多的插件来在webpack上做一些辅助性的工作, 比如HtmlWebpackPlugin这种用来创建HTML文件的插件


谈谈你对promise的了解
分析: peomise是目前开发中经常会用到的一个知识点, 所以它是必须要掌握的
解答: 
● 首先promise是ES6提出的一个异步编程解决方案, 相比于传统的容易陷入回调地狱的异步回调方案来说, promise会让异步的调用变得更加的优雅
● ES6规定promise是一个构造函数, 所以我们需要通过new关键字来生成一个promise的实例对象
● promise的构造函数接收一个函数作为参数, 函数中的代码在new promise的时候, 会立即执行, 我们可以在这里去执行异步代码的操作, 并且该函数默认存在两个参数分别是resolve和reject, 这两个参数也是函数, 用来标记异步执行的状态
● 比如resolve, 当promise的异步操作完成的时候, 我们可以调用resolve函数, 来标记当前的异步操作已经完成
● 而reject, 是在异步操作失败的时候进行调用, 用来标记当前的异步操作失败了
● 这些标记的状态我们可以通过promise实例对象的.then和.catch方法接收, 其中.then方法是异步完成的回调, .catch是异步失败的回调



null和undefined的区别分别是什么?
分析: 这个问题多出现在笔试中, 是考察工程师基础知识掌握程度的一个很好的题目
解答: 
● undefined: 表示不存在这个值, 它是一个变量最原始的状态
● null: 它是一个具体的值, 只不过这个值是一个空值而已

比如说: 我们声明一个变量, 其实就是在内存中开辟一块空间, 但是我们并没有赋值, 这个时候它的内容就是undefind
null怎么理解呢, 比如说: 我们定义一个变量赋值为null, 也是在内存中开辟一块空间, 在里面放了一个null

什么是同步? 什么是异步? 他们的区别时什么?
分析: 对于任何一门编程语言来说, 同步和异步的概念永远都是一个重点问题
解答:
● 同步: 线程被阻塞, 等待任务返回结果
● 异步: 异步就是线程不会被阻塞, 任务完成通知JS引擎
怎么理解呢? 比如说: 我给移动打电话, 让他帮忙查一下花费, 他说稍等, 我们不会立马挂断电话, 一会他说: 你的花费还有11, 这个时候, 我们才会挂断电话, 这个操作就是同步, 异步呢, 比如说: 朋友打电话找我借钱, 立马就挂断了, 我把钱转给他之后, 通知了他一下, 说转过去了, 这个过程呢,其实就是异步


什么是EventLoop?
分析: 询问EventLoop, 主要就是询问JS的一个线程机制, 因为你只有了解了JS的单线程机制, 你才可以理解什么是EventLoop
解答: 
● javascript语言的一大特点就是单线程, 也就是说, 同一时间只能做一件事
● 单线程就意味着, 所有任务需要排队吗前一个任务结束, 才会执行后一个任务, 如果前一个任务耗时很长, 后一个任务就不得不一直等着
● 于是, 所有任务可以分成两种, 一种是同步任务, 一种是异步任务
● 同步任务指的是, 在主线程上排队执行的任务, 只有前一个任务执行完毕, 才能执行后一个任务
● 异步任务指的是, 不进入主线程, 而进入"任务队列"的任务, 只有"任务队列"通知主线程, 某个异步任务可以执行了, 该任务才会进入主线程执行
● 而当主线程的任务完成之后, 主线程从"任务队列"中读取事件, 这个过程是循环不断的, 这就是EventLoop(事件循环)


bind、call、apply的区别?
分析: 这三个方法在react的项目中会使用的非常多, 并且因为这三个方法会牵扯到this的指向问题, 所以在面试中被问到的概率还是非常大的
解答: 
● call和apply都是为了了解改变this的指向, 作用都是相同的, 知识传参的方式不同
● 除了第一个参数外, call可以接收一个参数列表, apply只接收一个数组
● bind和其他两个方法作用也是一致的, 知识该方法会返回一个函数, 并且我们可以通过bind实现柯里化


typeof和instanceof的区别?
分析: typeof与instanceof都是在项目中会被经常使用到的方法, 并且这两个方法的作用经常容易搞混, 所以在面试中, 这两个方法会经常被问到
解答: 
● typeof: 会返回一个值的类型, 对于基本数据类型, 除了null都可以返回正确的类型, 而对于null则会返回object, 这是js的一个bug, 而对于引用数据类型来说, 除了函数之外, 其他的都会返回object
● instanceof: 他是用来判断一个对象是都是另一个对象的实例, 注意它只能用来判断对象


Vue方面

请说一下对Vue生命周期的理解
分析: 如果要使用Vue来开发项目, 那么Vue生命周期部分, 也是必须要掌握的一个内容
解答: 
● Vue实例从创建到销毁的过程, 就是生命周期
● 总共分为8的阶段, 创建前后, 载入前后, 更新前后, 摧毁前后


请说一下Vue实现双向数据绑定的原理
分析: 如果你的简历中有关于Vue的内容, 那么Vue实现双向数据绑定的原理是有很大概率会被问到的一个知识点
解答: 
● vue实现数据双向绑定主要是: 采用数据劫持结合发布者-订阅者模式的方式
● 数据劫持: 通过Object.defineProperty()来劫持对象各个属性的setter, getter。
● 发布者-订阅者模式: 在数据变动时发布者发布消息给订阅者, 触发响应监听回调
● 总的来说: 当把一个普通javascript对象传给Vue实例来作为它的data选项时, Vue将遍历它的属性, 用Object.defineProperty()监听他们的getter/setter方法, 这样, 他们就可以让Vue追踪依赖, 在对象的属性被访问(get)和修改(set)时通知变化


请说一下Vue中如何实现参数的传递?
分析: Vue中各个组件之间的参数传递, 是使用Vue进行项目开发时大概率会用到的一个知识点
解答: 
● 父组件和子组件传值: 子组件通过props属性接收数据
● 子组件和父组件传值: 子组件通过$emit方法传递参数
● 兄弟组件传值: 对于兄弟组件之间传值来说, 兄弟组件之间其实没有任何的相互依赖关系, 也就是说他们之前其实没有关系, 而对于没有关系的两个组件, 如果想要进行数据传递, 那么就需要有一个第三方, 通过这个第三方来为两个没有关系的组件建立关系, 目前比较通用的方式, 主要有两种: 
  ○ 一个是eventBus方案, 建立一个事件中心, 通过它传递事件来进行数据传递
  ○ 第二个就是通过Vuex来进行数据共享



请说一下Vue的路由实现: hash模式和history模式
分析: 这个问题对于初、中级工程师来说被问到主要是一个加分项, 因为路由模式在进行项目开发的时候所产生的影响比较有限, 更大的影响是在项目部署之后的生产环境中

解答: 
● hash模式: 是vue-router的默认模式, 使用哈希, url中会出现#号字符, #以及#后面的字符称之为哈希( hash ), 特点: hash虽然在url中, 但不被包括在HTTP请求中
● history模式: 国内线上项目使用的比较多的还是history模式, 这种模式下URL中不会存在#这种难看的只读, 不过这种模式下, 需要后台进行配合, 因为Vue打包的项目通常是一个单页的应用, 也就是任何的URL其实指向的都是一个HTML文件, 所以我们需要在apache或者nginx中进行配置, 当URL匹配不到资源时, 指向同一个html页面的配置


<keep-alive></keep-alive>的作用是什么?
分析: keepAlive是构建公司级项目时经常会使用到的一个知识点
解答: keepAlive的作用: <keep-alive></ keep-alive>包裹动态组件, 会魂村不活动的组件实例, 主要用于保留组件状态或避免重新渲染


webpack 中 rules 配置less的顺序
vue2 和 vue3中 router 有什么区别